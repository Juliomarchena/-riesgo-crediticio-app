from flask import Flask, request, jsonify
from flask_cors import CORS
import pickle
import numpy as np
import pandas as pd
import os

app = Flask(__name__)
CORS(app)  # Permite que Power Apps llame a tu API

# API Key para seguridad (cambiar en producci√≥n)
# API_KEY = os.environ.get('API_KEY', 'API_KEY = 'mi-clave-super-secreta-2026')
from dotenv import load_dotenv
load_dotenv()
API_KEY = os.getenv('API_KEY', 'mi-clave-super-secreta-2026')

# Cargar el modelo al iniciar
try:
    with open('modelo_riesgo_crediticio.pkl', 'rb') as file:
        modelo = pickle.load(file)
    print("‚úÖ Modelo cargado exitosamente")
except Exception as e:
    print(f"‚ö†Ô∏è Error al cargar modelo: {e}")
    modelo = None

def require_api_key(f):
    """Decorador para validar API Key"""
    from functools import wraps
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        if api_key != API_KEY:
            return jsonify({
                'error': 'API key inv√°lida o faltante',
                'mensaje': 'Incluye el header X-API-Key con tu clave'
            }), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/', methods=['GET'])
def home():
    """Endpoint principal - informaci√≥n de la API"""
    return jsonify({
        "mensaje": "üè¶ API de Riesgo Crediticio - Activa",
        "version": "1.0",
        "autor": "Julius",
        "endpoints": {
            "/": "Informaci√≥n de la API",
            "/health": "Estado de salud del servicio",
            "/predict": "Realizar predicci√≥n (POST con datos del cliente)"
        },
        "nota": "Endpoint /predict requiere API Key en header X-API-Key"
    }), 200

@app.route('/health', methods=['GET'])
def health():
    """Health check para Railway"""
    modelo_cargado = modelo is not None
    return jsonify({
        'status': 'healthy' if modelo_cargado else 'unhealthy',
        'modelo_cargado': modelo_cargado
    }), 200 if modelo_cargado else 503

@app.route('/predict', methods=['POST'])
@require_api_key
def predict():
    """
    Endpoint principal de predicci√≥n

    Espera un JSON con las siguientes caracter√≠sticas:
    - credit_policy: 0 o 1
    - int_rate: Tasa de inter√©s (0-1)
    - installment: Monto de cuota mensual
    - log_annual_inc: Log del ingreso anual
    - dti: Ratio deuda/ingreso
    - fico: Puntaje FICO (300-850)
    - days_with_cr_line: D√≠as con l√≠nea de cr√©dito
    - revol_bal: Balance revolving
    - revol_util: Utilizaci√≥n revolving (%)
    - inq_last_6mths: Consultas √∫ltimos 6 meses
    - delinq_2yrs: Morosidades √∫ltimos 2 a√±os
    - pub_rec: Registros p√∫blicos negativos
    """
    try:
        # Validar que el modelo est√© cargado
        if modelo is None:
            return jsonify({
                'error': 'Modelo no disponible',
                'mensaje': 'El modelo PKL no se pudo cargar'
            }), 503

        # Recibir datos del cliente
        datos = request.get_json()

        if not datos:
            return jsonify({
                'error': 'Datos faltantes',
                'mensaje': 'Env√≠a un JSON con las caracter√≠sticas del cliente'
            }), 400

        # Extraer caracter√≠sticas en el MISMO orden del entrenamiento
        try:
            caracteristicas = [
                float(datos.get('credit_policy', 0)),
                float(datos.get('int_rate', 0)),
                float(datos.get('installment', 0)),
                float(datos.get('log_annual_inc', 0)),
                float(datos.get('dti', 0)),
                float(datos.get('fico', 0)),
                float(datos.get('days_with_cr_line', 0)),
                float(datos.get('revol_bal', 0)),
                float(datos.get('revol_util', 0)),
                float(datos.get('inq_last_6mths', 0)),
                float(datos.get('delinq_2yrs', 0)),
                float(datos.get('pub_rec', 0))
            ]
        except (ValueError, TypeError) as e:
            return jsonify({
                'error': 'Formato de datos inv√°lido',
                'mensaje': f'Todas las caracter√≠sticas deben ser n√∫meros: {str(e)}'
            }), 400

        # Validaciones b√°sicas
        if not (300 <= caracteristicas[5] <= 850):  # FICO
            return jsonify({
                'error': 'Validaci√≥n fallida',
                'mensaje': 'El puntaje FICO debe estar entre 300 y 850'
            }), 400

        if not (0 <= caracteristicas[1] <= 1):  # int_rate
            return jsonify({
                'error': 'Validaci√≥n fallida',
                'mensaje': 'La tasa de inter√©s debe estar entre 0 y 1'
            }), 400

        # Convertir a formato que espera el modelo
        X = np.array(caracteristicas).reshape(1, -1)

        # Realizar predicci√≥n
        prediccion = modelo.predict(X)[0]
        probabilidad = modelo.predict_proba(X)[0]

        # Determinar nivel de riesgo
        prob_riesgo = float(probabilidad[1])
        if prob_riesgo < 0.3:
            nivel_riesgo = "Bajo"
            color = "green"
        elif prob_riesgo < 0.7:
            nivel_riesgo = "Medio"
            color = "yellow"
        else:
            nivel_riesgo = "Alto"
            color = "red"

        # Preparar respuesta detallada
        resultado = {
            'prediccion': int(prediccion),
            'riesgo': 'No Riesgoso' if prediccion == 0 else 'Riesgoso',
            'nivel_riesgo': nivel_riesgo,
            'color_recomendado': color,
            'probabilidad_no_riesgo': round(float(probabilidad[0]) * 100, 2),
            'probabilidad_riesgo': round(float(probabilidad[1]) * 100, 2),
            'confianza': f"{round(max(probabilidad) * 100, 2)}%",
            'recomendacion': generar_recomendacion(prediccion, prob_riesgo, caracteristicas),
            'datos_recibidos': {
                'fico': int(caracteristicas[5]),
                'int_rate': round(caracteristicas[1], 4),
                'dti': round(caracteristicas[4], 2)
            }
        }

        return jsonify(resultado), 200

    except Exception as e:
        return jsonify({
            'error': 'Error interno del servidor',
            'mensaje': str(e),
            'tipo': type(e).__name__
        }), 500

def generar_recomendacion(prediccion, prob_riesgo, caracteristicas):
    """Genera recomendaciones basadas en la predicci√≥n"""
    fico = caracteristicas[5]
    dti = caracteristicas[4]

    if prediccion == 0:  # No riesgoso
        if prob_riesgo < 0.2:
            return "‚úÖ Cliente excelente - Aprobar cr√©dito con condiciones favorables"
        else:
            return "‚úÖ Cliente aceptable - Aprobar con condiciones est√°ndar"
    else:  # Riesgoso
        recomendaciones = ["‚ö†Ô∏è Cliente de alto riesgo."]

        if fico < 600:
            recomendaciones.append("Puntaje FICO bajo.")
        if dti > 30:
            recomendaciones.append("Ratio deuda/ingreso elevado.")

        recomendaciones.append("Considerar garant√≠as adicionales o rechazar.")

        return " ".join(recomendaciones)

@app.route('/test', methods=['GET'])
def test_prediction():
    """
    Endpoint de prueba con datos de ejemplo
    √ötil para verificar que todo funciona
    """
    datos_prueba = {
        'credit_policy': 1,
        'int_rate': 0.1357,
        'installment': 366.86,
        'log_annual_inc': 11.35,
        'dti': 19.48,
        'fico': 737,
        'days_with_cr_line': 5639.96,
        'revol_bal': 28854,
        'revol_util': 52.10,
        'inq_last_6mths': 1,
        'delinq_2yrs': 0,
        'pub_rec': 0
    }

    return jsonify({
        'mensaje': 'Datos de prueba',
        'nota': 'Usa estos datos en POST /predict para probar',
        'datos': datos_prueba
    }), 200

# if __name__ == '__main__':
 #   port = int(os.environ.get('PORT', 5000))
 #   debug = os.environ.get('DEBUG', 'False') == 'True'

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=port, debug=True)  # ‚Üê Cambia False a True


    print(f"üöÄ Iniciando servidor en puerto {port}")
    print(f"üîê API Key configurada: {'S√≠' if API_KEY else 'No'}")
    print(f"ü§ñ Modelo cargado: {'S√≠' if modelo else 'No'}")

    app.run(host='0.0.0.0', port=port, debug=debug)
